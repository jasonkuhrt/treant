// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`generate > generates parser from simple grammar 1`] = `
{
  "files": {
    "grammarJson": "{
  "$schema": "https://tree-sitter.github.io/tree-sitter/assets/schemas/grammar.schema.json",
  "name": "test",
  "rules": {
    "source_file": {
      "type": "SYMBOL",
      "name": "expression"
    },
    "expression": {
      "type": "STRING",
      "value": "hello"
    }
  },
  "extras": [
    {
      "type": "PATTERN",
      "value": "\\\\s"
    }
  ],
  "conflicts": [],
  "precedences": [],
  "externals": [],
  "inline": [],
  "supertypes": [],
  "reserved": {}
}",
    "headers": {
      "allocH": "#ifndef TREE_SITTER_ALLOC_H_
#define TREE_SITTER_ALLOC_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

// Allow clients to override allocation functions
#ifdef TREE_SITTER_REUSE_ALLOCATOR

extern void *(*ts_current_malloc)(size_t size);
extern void *(*ts_current_calloc)(size_t count, size_t size);
extern void *(*ts_current_realloc)(void *ptr, size_t size);
extern void (*ts_current_free)(void *ptr);

#ifndef ts_malloc
#define ts_malloc  ts_current_malloc
#endif
#ifndef ts_calloc
#define ts_calloc  ts_current_calloc
#endif
#ifndef ts_realloc
#define ts_realloc ts_current_realloc
#endif
#ifndef ts_free
#define ts_free    ts_current_free
#endif

#else

#ifndef ts_malloc
#define ts_malloc  malloc
#endif
#ifndef ts_calloc
#define ts_calloc  calloc
#endif
#ifndef ts_realloc
#define ts_realloc realloc
#endif
#ifndef ts_free
#define ts_free    free
#endif

#endif

#ifdef __cplusplus
}
#endif

#endif // TREE_SITTER_ALLOC_H_
",
      "arrayH": "#ifndef TREE_SITTER_ARRAY_H_
#define TREE_SITTER_ARRAY_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "./alloc.h"

#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4101)
#elif defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#endif

#define Array(T)       \\
  struct {             \\
    T *contents;       \\
    uint32_t size;     \\
    uint32_t capacity; \\
  }

/// Initialize an array.
#define array_init(self) \\
  ((self)->size = 0, (self)->capacity = 0, (self)->contents = NULL)

/// Create an empty array.
#define array_new() \\
  { NULL, 0, 0 }

/// Get a pointer to the element at a given \`index\` in the array.
#define array_get(self, _index) \\
  (assert((uint32_t)(_index) < (self)->size), &(self)->contents[_index])

/// Get a pointer to the first element in the array.
#define array_front(self) array_get(self, 0)

/// Get a pointer to the last element in the array.
#define array_back(self) array_get(self, (self)->size - 1)

/// Clear the array, setting its size to zero. Note that this does not free any
/// memory allocated for the array's contents.
#define array_clear(self) ((self)->size = 0)

/// Reserve \`new_capacity\` elements of space in the array. If \`new_capacity\` is
/// less than the array's current capacity, this function has no effect.
#define array_reserve(self, new_capacity) \\
  _array__reserve((Array *)(self), array_elem_size(self), new_capacity)

/// Free any memory allocated for this array. Note that this does not free any
/// memory allocated for the array's contents.
#define array_delete(self) _array__delete((Array *)(self))

/// Push a new \`element\` onto the end of the array.
#define array_push(self, element)                            \\
  (_array__grow((Array *)(self), 1, array_elem_size(self)), \\
   (self)->contents[(self)->size++] = (element))

/// Increase the array's size by \`count\` elements.
/// New elements are zero-initialized.
#define array_grow_by(self, count) \\
  do { \\
    if ((count) == 0) break; \\
    _array__grow((Array *)(self), count, array_elem_size(self)); \\
    memset((self)->contents + (self)->size, 0, (count) * array_elem_size(self)); \\
    (self)->size += (count); \\
  } while (0)

/// Append all elements from one array to the end of another.
#define array_push_all(self, other)                                       \\
  array_extend((self), (other)->size, (other)->contents)

/// Append \`count\` elements to the end of the array, reading their values from the
/// \`contents\` pointer.
#define array_extend(self, count, contents)                    \\
  _array__splice(                                               \\
    (Array *)(self), array_elem_size(self), (self)->size, \\
    0, count,  contents                                        \\
  )

/// Remove \`old_count\` elements from the array starting at the given \`index\`. At
/// the same index, insert \`new_count\` new elements, reading their values from the
/// \`new_contents\` pointer.
#define array_splice(self, _index, old_count, new_count, new_contents)  \\
  _array__splice(                                                       \\
    (Array *)(self), array_elem_size(self), _index,                \\
    old_count, new_count, new_contents                                 \\
  )

/// Insert one \`element\` into the array at the given \`index\`.
#define array_insert(self, _index, element) \\
  _array__splice((Array *)(self), array_elem_size(self), _index, 0, 1, &(element))

/// Remove one element from the array at the given \`index\`.
#define array_erase(self, _index) \\
  _array__erase((Array *)(self), array_elem_size(self), _index)

/// Pop the last element off the array, returning the element by value.
#define array_pop(self) ((self)->contents[--(self)->size])

/// Assign the contents of one array to another, reallocating if necessary.
#define array_assign(self, other) \\
  _array__assign((Array *)(self), (const Array *)(other), array_elem_size(self))

/// Swap one array with another
#define array_swap(self, other) \\
  _array__swap((Array *)(self), (Array *)(other))

/// Get the size of the array contents
#define array_elem_size(self) (sizeof *(self)->contents)

/// Search a sorted array for a given \`needle\` value, using the given \`compare\`
/// callback to determine the order.
///
/// If an existing element is found to be equal to \`needle\`, then the \`index\`
/// out-parameter is set to the existing value's index, and the \`exists\`
/// out-parameter is set to true. Otherwise, \`index\` is set to an index where
/// \`needle\` should be inserted in order to preserve the sorting, and \`exists\`
/// is set to false.
#define array_search_sorted_with(self, compare, needle, _index, _exists) \\
  _array__search_sorted(self, 0, compare, , needle, _index, _exists)

/// Search a sorted array for a given \`needle\` value, using integer comparisons
/// of a given struct field (specified with a leading dot) to determine the order.
///
/// See also \`array_search_sorted_with\`.
#define array_search_sorted_by(self, field, needle, _index, _exists) \\
  _array__search_sorted(self, 0, _compare_int, field, needle, _index, _exists)

/// Insert a given \`value\` into a sorted array, using the given \`compare\`
/// callback to determine the order.
#define array_insert_sorted_with(self, compare, value) \\
  do { \\
    unsigned _index, _exists; \\
    array_search_sorted_with(self, compare, &(value), &_index, &_exists); \\
    if (!_exists) array_insert(self, _index, value); \\
  } while (0)

/// Insert a given \`value\` into a sorted array, using integer comparisons of
/// a given struct field (specified with a leading dot) to determine the order.
///
/// See also \`array_search_sorted_by\`.
#define array_insert_sorted_by(self, field, value) \\
  do { \\
    unsigned _index, _exists; \\
    array_search_sorted_by(self, field, (value) field, &_index, &_exists); \\
    if (!_exists) array_insert(self, _index, value); \\
  } while (0)

// Private

typedef Array(void) Array;

/// This is not what you're looking for, see \`array_delete\`.
static inline void _array__delete(Array *self) {
  if (self->contents) {
    ts_free(self->contents);
    self->contents = NULL;
    self->size = 0;
    self->capacity = 0;
  }
}

/// This is not what you're looking for, see \`array_erase\`.
static inline void _array__erase(Array *self, size_t element_size,
                                uint32_t index) {
  assert(index < self->size);
  char *contents = (char *)self->contents;
  memmove(contents + index * element_size, contents + (index + 1) * element_size,
          (self->size - index - 1) * element_size);
  self->size--;
}

/// This is not what you're looking for, see \`array_reserve\`.
static inline void _array__reserve(Array *self, size_t element_size, uint32_t new_capacity) {
  if (new_capacity > self->capacity) {
    if (self->contents) {
      self->contents = ts_realloc(self->contents, new_capacity * element_size);
    } else {
      self->contents = ts_malloc(new_capacity * element_size);
    }
    self->capacity = new_capacity;
  }
}

/// This is not what you're looking for, see \`array_assign\`.
static inline void _array__assign(Array *self, const Array *other, size_t element_size) {
  _array__reserve(self, element_size, other->size);
  self->size = other->size;
  memcpy(self->contents, other->contents, self->size * element_size);
}

/// This is not what you're looking for, see \`array_swap\`.
static inline void _array__swap(Array *self, Array *other) {
  Array swap = *other;
  *other = *self;
  *self = swap;
}

/// This is not what you're looking for, see \`array_push\` or \`array_grow_by\`.
static inline void _array__grow(Array *self, uint32_t count, size_t element_size) {
  uint32_t new_size = self->size + count;
  if (new_size > self->capacity) {
    uint32_t new_capacity = self->capacity * 2;
    if (new_capacity < 8) new_capacity = 8;
    if (new_capacity < new_size) new_capacity = new_size;
    _array__reserve(self, element_size, new_capacity);
  }
}

/// This is not what you're looking for, see \`array_splice\`.
static inline void _array__splice(Array *self, size_t element_size,
                                 uint32_t index, uint32_t old_count,
                                 uint32_t new_count, const void *elements) {
  uint32_t new_size = self->size + new_count - old_count;
  uint32_t old_end = index + old_count;
  uint32_t new_end = index + new_count;
  assert(old_end <= self->size);

  _array__reserve(self, element_size, new_size);

  char *contents = (char *)self->contents;
  if (self->size > old_end) {
    memmove(
      contents + new_end * element_size,
      contents + old_end * element_size,
      (self->size - old_end) * element_size
    );
  }
  if (new_count > 0) {
    if (elements) {
      memcpy(
        (contents + index * element_size),
        elements,
        new_count * element_size
      );
    } else {
      memset(
        (contents + index * element_size),
        0,
        new_count * element_size
      );
    }
  }
  self->size += new_count - old_count;
}

/// A binary search routine, based on Rust's \`std::slice::binary_search_by\`.
/// This is not what you're looking for, see \`array_search_sorted_with\` or \`array_search_sorted_by\`.
#define _array__search_sorted(self, start, compare, suffix, needle, _index, _exists) \\
  do { \\
    *(_index) = start; \\
    *(_exists) = false; \\
    uint32_t size = (self)->size - *(_index); \\
    if (size == 0) break; \\
    int comparison; \\
    while (size > 1) { \\
      uint32_t half_size = size / 2; \\
      uint32_t mid_index = *(_index) + half_size; \\
      comparison = compare(&((self)->contents[mid_index] suffix), (needle)); \\
      if (comparison <= 0) *(_index) = mid_index; \\
      size -= half_size; \\
    } \\
    comparison = compare(&((self)->contents[*(_index)] suffix), (needle)); \\
    if (comparison == 0) *(_exists) = true; \\
    else if (comparison < 0) *(_index) += 1; \\
  } while (0)

/// Helper macro for the \`_sorted_by\` routines below. This takes the left (existing)
/// parameter by reference in order to work with the generic sorting function above.
#define _compare_int(a, b) ((int)*(a) - (int)(b))

#ifdef _MSC_VER
#pragma warning(pop)
#elif defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#ifdef __cplusplus
}
#endif

#endif  // TREE_SITTER_ARRAY_H_
",
      "parserH": "#ifndef TREE_SITTER_PARSER_H_
#define TREE_SITTER_PARSER_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define ts_builtin_sym_error ((TSSymbol)-1)
#define ts_builtin_sym_end 0
#define TREE_SITTER_SERIALIZATION_BUFFER_SIZE 1024

#ifndef TREE_SITTER_API_H_
typedef uint16_t TSStateId;
typedef uint16_t TSSymbol;
typedef uint16_t TSFieldId;
typedef struct TSLanguage TSLanguage;
typedef struct TSLanguageMetadata {
  uint8_t major_version;
  uint8_t minor_version;
  uint8_t patch_version;
} TSLanguageMetadata;
#endif

typedef struct {
  TSFieldId field_id;
  uint8_t child_index;
  bool inherited;
} TSFieldMapEntry;

// Used to index the field and supertype maps.
typedef struct {
  uint16_t index;
  uint16_t length;
} TSMapSlice;

typedef struct {
  bool visible;
  bool named;
  bool supertype;
} TSSymbolMetadata;

typedef struct TSLexer TSLexer;

struct TSLexer {
  int32_t lookahead;
  TSSymbol result_symbol;
  void (*advance)(TSLexer *, bool);
  void (*mark_end)(TSLexer *);
  uint32_t (*get_column)(TSLexer *);
  bool (*is_at_included_range_start)(const TSLexer *);
  bool (*eof)(const TSLexer *);
  void (*log)(const TSLexer *, const char *, ...);
};

typedef enum {
  TSParseActionTypeShift,
  TSParseActionTypeReduce,
  TSParseActionTypeAccept,
  TSParseActionTypeRecover,
} TSParseActionType;

typedef union {
  struct {
    uint8_t type;
    TSStateId state;
    bool extra;
    bool repetition;
  } shift;
  struct {
    uint8_t type;
    uint8_t child_count;
    TSSymbol symbol;
    int16_t dynamic_precedence;
    uint16_t production_id;
  } reduce;
  uint8_t type;
} TSParseAction;

typedef struct {
  uint16_t lex_state;
  uint16_t external_lex_state;
} TSLexMode;

typedef struct {
  uint16_t lex_state;
  uint16_t external_lex_state;
  uint16_t reserved_word_set_id;
} TSLexerMode;

typedef union {
  TSParseAction action;
  struct {
    uint8_t count;
    bool reusable;
  } entry;
} TSParseActionEntry;

typedef struct {
  int32_t start;
  int32_t end;
} TSCharacterRange;

struct TSLanguage {
  uint32_t abi_version;
  uint32_t symbol_count;
  uint32_t alias_count;
  uint32_t token_count;
  uint32_t external_token_count;
  uint32_t state_count;
  uint32_t large_state_count;
  uint32_t production_id_count;
  uint32_t field_count;
  uint16_t max_alias_sequence_length;
  const uint16_t *parse_table;
  const uint16_t *small_parse_table;
  const uint32_t *small_parse_table_map;
  const TSParseActionEntry *parse_actions;
  const char * const *symbol_names;
  const char * const *field_names;
  const TSMapSlice *field_map_slices;
  const TSFieldMapEntry *field_map_entries;
  const TSSymbolMetadata *symbol_metadata;
  const TSSymbol *public_symbol_map;
  const uint16_t *alias_map;
  const TSSymbol *alias_sequences;
  const TSLexerMode *lex_modes;
  bool (*lex_fn)(TSLexer *, TSStateId);
  bool (*keyword_lex_fn)(TSLexer *, TSStateId);
  TSSymbol keyword_capture_token;
  struct {
    const bool *states;
    const TSSymbol *symbol_map;
    void *(*create)(void);
    void (*destroy)(void *);
    bool (*scan)(void *, TSLexer *, const bool *symbol_whitelist);
    unsigned (*serialize)(void *, char *);
    void (*deserialize)(void *, const char *, unsigned);
  } external_scanner;
  const TSStateId *primary_state_ids;
  const char *name;
  const TSSymbol *reserved_words;
  uint16_t max_reserved_word_set_size;
  uint32_t supertype_count;
  const TSSymbol *supertype_symbols;
  const TSMapSlice *supertype_map_slices;
  const TSSymbol *supertype_map_entries;
  TSLanguageMetadata metadata;
};

static inline bool set_contains(const TSCharacterRange *ranges, uint32_t len, int32_t lookahead) {
  uint32_t index = 0;
  uint32_t size = len - index;
  while (size > 1) {
    uint32_t half_size = size / 2;
    uint32_t mid_index = index + half_size;
    const TSCharacterRange *range = &ranges[mid_index];
    if (lookahead >= range->start && lookahead <= range->end) {
      return true;
    } else if (lookahead > range->end) {
      index = mid_index;
    }
    size -= half_size;
  }
  const TSCharacterRange *range = &ranges[index];
  return (lookahead >= range->start && lookahead <= range->end);
}

/*
 *  Lexer Macros
 */

#ifdef _MSC_VER
#define UNUSED __pragma(warning(suppress : 4101))
#else
#define UNUSED __attribute__((unused))
#endif

#define START_LEXER()           \\
  bool result = false;          \\
  bool skip = false;            \\
  UNUSED                        \\
  bool eof = false;             \\
  int32_t lookahead;            \\
  goto start;                   \\
  next_state:                   \\
  lexer->advance(lexer, skip);  \\
  start:                        \\
  skip = false;                 \\
  lookahead = lexer->lookahead;

#define ADVANCE(state_value) \\
  {                          \\
    state = state_value;     \\
    goto next_state;         \\
  }

#define ADVANCE_MAP(...)                                              \\
  {                                                                   \\
    static const uint16_t map[] = { __VA_ARGS__ };                    \\
    for (uint32_t i = 0; i < sizeof(map) / sizeof(map[0]); i += 2) {  \\
      if (map[i] == lookahead) {                                      \\
        state = map[i + 1];                                           \\
        goto next_state;                                              \\
      }                                                               \\
    }                                                                 \\
  }

#define SKIP(state_value) \\
  {                       \\
    skip = true;          \\
    state = state_value;  \\
    goto next_state;      \\
  }

#define ACCEPT_TOKEN(symbol_value)     \\
  result = true;                       \\
  lexer->result_symbol = symbol_value; \\
  lexer->mark_end(lexer);

#define END_STATE() return result;

/*
 *  Parse Table Macros
 */

#define SMALL_STATE(id) ((id) - LARGE_STATE_COUNT)

#define STATE(id) id

#define ACTIONS(id) id

#define SHIFT(state_value)            \\
  {{                                  \\
    .shift = {                        \\
      .type = TSParseActionTypeShift, \\
      .state = (state_value)          \\
    }                                 \\
  }}

#define SHIFT_REPEAT(state_value)     \\
  {{                                  \\
    .shift = {                        \\
      .type = TSParseActionTypeShift, \\
      .state = (state_value),         \\
      .repetition = true              \\
    }                                 \\
  }}

#define SHIFT_EXTRA()                 \\
  {{                                  \\
    .shift = {                        \\
      .type = TSParseActionTypeShift, \\
      .extra = true                   \\
    }                                 \\
  }}

#define REDUCE(symbol_name, children, precedence, prod_id) \\
  {{                                                       \\
    .reduce = {                                            \\
      .type = TSParseActionTypeReduce,                     \\
      .symbol = symbol_name,                               \\
      .child_count = children,                             \\
      .dynamic_precedence = precedence,                    \\
      .production_id = prod_id                             \\
    },                                                     \\
  }}

#define RECOVER()                    \\
  {{                                 \\
    .type = TSParseActionTypeRecover \\
  }}

#define ACCEPT_INPUT()              \\
  {{                                \\
    .type = TSParseActionTypeAccept \\
  }}

#ifdef __cplusplus
}
#endif

#endif  // TREE_SITTER_PARSER_H_
",
    },
    "nodeTypes": "[
  {
    "type": "source_file",
    "named": true,
    "root": true,
    "fields": {},
    "children": {
      "multiple": false,
      "required": true,
      "types": [
        {
          "type": "expression",
          "named": true
        }
      ]
    }
  },
  {
    "type": "expression",
    "named": true
  }
]",
    "parserC": "/* Automatically @generated by tree-sitter v0.25.8 */

#include "tree_sitter/parser.h"

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#endif

#define LANGUAGE_VERSION 14
#define STATE_COUNT 4
#define LARGE_STATE_COUNT 2
#define SYMBOL_COUNT 3
#define ALIAS_COUNT 0
#define TOKEN_COUNT 2
#define EXTERNAL_TOKEN_COUNT 0
#define FIELD_COUNT 0
#define MAX_ALIAS_SEQUENCE_LENGTH 1
#define MAX_RESERVED_WORD_SET_SIZE 0
#define PRODUCTION_ID_COUNT 1
#define SUPERTYPE_COUNT 0

enum ts_symbol_identifiers {
  sym_expression = 1,
  sym_source_file = 2,
};

static const char * const ts_symbol_names[] = {
  [ts_builtin_sym_end] = "end",
  [sym_expression] = "expression",
  [sym_source_file] = "source_file",
};

static const TSSymbol ts_symbol_map[] = {
  [ts_builtin_sym_end] = ts_builtin_sym_end,
  [sym_expression] = sym_expression,
  [sym_source_file] = sym_source_file,
};

static const TSSymbolMetadata ts_symbol_metadata[] = {
  [ts_builtin_sym_end] = {
    .visible = false,
    .named = true,
  },
  [sym_expression] = {
    .visible = true,
    .named = true,
  },
  [sym_source_file] = {
    .visible = true,
    .named = true,
  },
};

static const TSSymbol ts_alias_sequences[PRODUCTION_ID_COUNT][MAX_ALIAS_SEQUENCE_LENGTH] = {
  [0] = {0},
};

static const uint16_t ts_non_terminal_alias_map[] = {
  0,
};

static const TSStateId ts_primary_state_ids[STATE_COUNT] = {
  [0] = 0,
  [1] = 1,
  [2] = 2,
  [3] = 3,
};

static bool ts_lex(TSLexer *lexer, TSStateId state) {
  START_LEXER();
  eof = lexer->eof(lexer);
  switch (state) {
    case 0:
      if (eof) ADVANCE(5);
      if (lookahead == 'h') ADVANCE(1);
      if (('\\t' <= lookahead && lookahead <= '\\r') ||
          lookahead == ' ') SKIP(0);
      END_STATE();
    case 1:
      if (lookahead == 'e') ADVANCE(3);
      END_STATE();
    case 2:
      if (lookahead == 'l') ADVANCE(4);
      END_STATE();
    case 3:
      if (lookahead == 'l') ADVANCE(2);
      END_STATE();
    case 4:
      if (lookahead == 'o') ADVANCE(6);
      END_STATE();
    case 5:
      ACCEPT_TOKEN(ts_builtin_sym_end);
      END_STATE();
    case 6:
      ACCEPT_TOKEN(sym_expression);
      END_STATE();
    default:
      return false;
  }
}

static const TSLexMode ts_lex_modes[STATE_COUNT] = {
  [0] = {.lex_state = 0},
  [1] = {.lex_state = 0},
  [2] = {.lex_state = 0},
  [3] = {.lex_state = 0},
};

static const uint16_t ts_parse_table[LARGE_STATE_COUNT][SYMBOL_COUNT] = {
  [STATE(0)] = {
    [ts_builtin_sym_end] = ACTIONS(1),
    [sym_expression] = ACTIONS(1),
  },
  [STATE(1)] = {
    [sym_source_file] = STATE(3),
    [sym_expression] = ACTIONS(3),
  },
};

static const uint16_t ts_small_parse_table[] = {
  [0] = 1,
    ACTIONS(5), 1,
      ts_builtin_sym_end,
  [4] = 1,
    ACTIONS(7), 1,
      ts_builtin_sym_end,
};

static const uint32_t ts_small_parse_table_map[] = {
  [SMALL_STATE(2)] = 0,
  [SMALL_STATE(3)] = 4,
};

static const TSParseActionEntry ts_parse_actions[] = {
  [0] = {.entry = {.count = 0, .reusable = false}},
  [1] = {.entry = {.count = 1, .reusable = false}}, RECOVER(),
  [3] = {.entry = {.count = 1, .reusable = true}}, SHIFT(2),
  [5] = {.entry = {.count = 1, .reusable = true}}, REDUCE(sym_source_file, 1, 0, 0),
  [7] = {.entry = {.count = 1, .reusable = true}},  ACCEPT_INPUT(),
};

#ifdef __cplusplus
extern "C" {
#endif
#ifdef TREE_SITTER_HIDE_SYMBOLS
#define TS_PUBLIC
#elif defined(_WIN32)
#define TS_PUBLIC __declspec(dllexport)
#else
#define TS_PUBLIC __attribute__((visibility("default")))
#endif

TS_PUBLIC const TSLanguage *tree_sitter_test(void) {
  static const TSLanguage language = {
    .abi_version = LANGUAGE_VERSION,
    .symbol_count = SYMBOL_COUNT,
    .alias_count = ALIAS_COUNT,
    .token_count = TOKEN_COUNT,
    .external_token_count = EXTERNAL_TOKEN_COUNT,
    .state_count = STATE_COUNT,
    .large_state_count = LARGE_STATE_COUNT,
    .production_id_count = PRODUCTION_ID_COUNT,
    .field_count = FIELD_COUNT,
    .max_alias_sequence_length = MAX_ALIAS_SEQUENCE_LENGTH,
    .parse_table = &ts_parse_table[0][0],
    .small_parse_table = ts_small_parse_table,
    .small_parse_table_map = ts_small_parse_table_map,
    .parse_actions = ts_parse_actions,
    .symbol_names = ts_symbol_names,
    .symbol_metadata = ts_symbol_metadata,
    .public_symbol_map = ts_symbol_map,
    .alias_map = ts_non_terminal_alias_map,
    .alias_sequences = &ts_alias_sequences[0][0],
    .lex_modes = (const void*)ts_lex_modes,
    .lex_fn = ts_lex,
    .primary_state_ids = ts_primary_state_ids,
  };
  return &language;
}
#ifdef __cplusplus
}
#endif
",
  },
  "parsed": {
    "grammar": {
      "$schema": "https://tree-sitter.github.io/tree-sitter/assets/schemas/grammar.schema.json",
      "conflicts": [],
      "externals": [],
      "extras": [
        {
          "type": "PATTERN",
          "value": "\\s",
        },
      ],
      "inline": [],
      "name": "test",
      "precedences": [],
      "reserved": {},
      "rules": {
        "expression": {
          "type": "STRING",
          "value": "hello",
        },
        "source_file": {
          "name": "expression",
          "type": "SYMBOL",
        },
      },
      "supertypes": [],
    },
    "nodeTypes": [
      {
        "children": {
          "multiple": false,
          "required": true,
          "types": [
            {
              "named": true,
              "type": "expression",
            },
          ],
        },
        "fields": {},
        "named": true,
        "root": true,
        "type": "source_file",
      },
      {
        "named": true,
        "type": "expression",
      },
    ],
  },
}
`;
